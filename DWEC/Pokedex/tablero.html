<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Batalla Pokémon</title>
  <!-- Se incluye Vue 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <!-- Se enlaza la hoja de estilos existente -->
  <link rel="stylesheet" href="tablero.css" />
  <!-- Estilos adicionales para el configurador, marcador y modal de batalla -->
</head>
<body>
  <div id="app">
    <!-- Panel de Configurador (izquierda) -->
    <div class="configurador" v-if="!battleModalAbierto">
      <h2>Configurador</h2>
      <button @click="vaciarTablero">Vaciar Tablero</button>
      <button @click="comenzarBatalla">Comenzar Batalla</button>
    </div>

    <!-- Marcador (derecha) -->
    <div class="scoreboard" v-if="!battleModalAbierto">
      <h2>Marcador</h2>
      <p>Jugador 1: {{ remainingJugador1 }} / 5</p>
      <p>Jugador 2: {{ remainingJugador2 }} / 5</p>
    </div>

    <!-- Tablero de selección de Pokémon (se oculta durante la batalla) -->
    <div class="tablero" v-if="!battleModalAbierto">
      <h1 class="titulo">{{ titulo }}</h1>

      <!-- Botones de acción -->
      <div class="actions">
        <button @click="generarPokemonAleatorios">Generar Pokémon Aleatorios</button>
        <button @click="abrirModal">Elegir Pokémon Manualmente</button>
      </div>

      <!-- Fila superior: Jugador 1 -->
      <div class="fila fila-superior">
        <div
          v-for="(pokemon, indice) in pokemonsJugador1"
          :key="indice"
          class="carta"
          :style="{
            backgroundImage: 'url(' + (pokemon.derrota ? './img/dorso.png' : (pokemon.sprites ? pokemon.sprites.front_default : '')) + ')'
          }"
          @click="elegirPokemon(pokemonsJugador1, indice)"
          :title="'Jugador 1: ' + (pokemon.nombre || 'Sin asignar')"
        >
          <div v-if="pokemon.nombre" class="nombre-pokemon">{{ pokemon.nombre }}</div>
        </div>
      </div>

      <!-- Texto VS -->
      <div class="vs">
        <span>VS</span>
      </div>

      <!-- Fila inferior: Jugador 2 -->
      <div class="fila fila-inferior">
        <div
          v-for="(pokemon, indice) in pokemonsJugador2"
          :key="indice"
          class="carta"
          :style="{
            backgroundImage: 'url(' + (pokemon.derrota ? './img/dorso.png' : (pokemon.sprites ? pokemon.sprites.front_default : '')) + ')'
          }"
          @click="elegirPokemon(pokemonsJugador2, indice)"
          :title="'Jugador 2: ' + (pokemon.nombre || 'Sin asignar')"
        >
          <div v-if="pokemon.nombre" class="nombre-pokemon">{{ pokemon.nombre }}</div>
        </div>
      </div>

      <!-- Nombres de jugadores -->
      <div class="jugadores">
        <div class="jugador" id="j1">J1</div>
        <div class="jugador" id="j2">J2</div>
      </div>
    </div>

    <!-- Modal para selección manual de Pokémon -->
    <div v-if="modalAbierto" class="modal-overlay">
      <div class="modal-content">
        <h2>Selecciona tus Pokémon</h2>
        <div class="modal-grid">
          <div
            v-for="(pokemon, indice) in todosLosPokemon"
            :key="indice"
            class="modal-carta"
            :style="{ backgroundImage: 'url(' + pokemon.sprites.front_default + ')' }"
            @click="seleccionarPokemon(pokemon)"
            :title="pokemon.nombre"
          >
            <div v-if="pokemon.nombre" class="nombre-pokemon">{{ pokemon.nombre }}</div>
          </div>
        </div>
        <button class="modal-close" @click="cerrarModal">Cerrar</button>
      </div>
    </div>

    <!-- Modal de Batalla: se abre al comenzar la pelea -->
    <div v-if="battleModalAbierto" class="modal-overlay">
      <div class="modal-content">
        <h2>Pelea {{ currentBattleIndex + 1 }}</h2>
        <p>Turno: Jugador {{ turno }}</p>
        <div v-if="activePokemonJugador1 && activePokemonJugador2">
          <p>
            {{ activePokemonJugador1.nombre }} (HP: {{ activePokemonJugador1.vida }})
            VS
            {{ activePokemonJugador2.nombre }} (HP: {{ activePokemonJugador2.vida }})
          </p>
        </div>
        <div class="battle-log">
          <div v-for="(log, index) in battleLog" :key="index">
            <p>{{ log }}</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Código JavaScript -->
  <script>
    const app = Vue.createApp({
      data() {
        return {
          titulo: "Batalla Pokémon",
          todosLosPokemon: [], // Todos los Pokémon (1ª generación)
          pokemonsJugador1: Array.from({ length: 5 }, () => ({})), // 5 cartas para el jugador 1
          pokemonsJugador2: Array.from({ length: 5 }, () => ({})), // 5 cartas para el jugador 2
          modalAbierto: false,
          // Variables para la pelea
          activePokemonJugador1: null,
          activePokemonJugador2: null,
          battleModalAbierto: false,
          turno: 1,
          battleLog: [],
          batallaFinalizada: false,
          currentBattleIndex: 0 // Indica el par de Pokémon actual (0 = primer vs. primer, 1 = segundo vs. segundo, etc.)
        };
      },
      computed: {
        // Número de Pokémon no derrotados por equipo
        remainingJugador1() {
          return this.pokemonsJugador1.filter(p => p.nombre && !p.derrota).length;
        },
        remainingJugador2() {
          return this.pokemonsJugador2.filter(p => p.nombre && !p.derrota).length;
        }
      },
      mounted() {
        this.obtenerPokemon();
      },
      methods: {
        // Obtiene los 151 primeros Pokémon de la API (incluyendo movimientos)
        async obtenerPokemon() {
          const primeraGeneracion = [];
          for (let i = 1; i <= 151; i++) {
            primeraGeneracion.push(
              fetch(`https://pokeapi.co/api/v2/pokemon/${i}`).then(res => res.json())
            );
          }
          const datosPokemon = await Promise.all(primeraGeneracion);
          this.todosLosPokemon = datosPokemon.map(pokemon => ({
            nombre: pokemon.name,
            sprites: pokemon.sprites,
            stats: pokemon.stats,
            movimientos: pokemon.moves, // Se guardan los movimientos
            derrota: false
          }));
        },

        // Selección manual desde el modal: se asigna el Pokémon al primer espacio vacío
        seleccionarPokemon(pokemon) {
          if (this.pokemonsJugador1.some(p => !p.nombre)) {
            const indice = this.pokemonsJugador1.findIndex(p => !p.nombre);
            this.pokemonsJugador1[indice] = Object.assign({}, pokemon);
          } else if (this.pokemonsJugador2.some(p => !p.nombre)) {
            const indice = this.pokemonsJugador2.findIndex(p => !p.nombre);
            this.pokemonsJugador2[indice] = Object.assign({}, pokemon);
          }
          this.cerrarModal();
        },

        abrirModal() {
          this.modalAbierto = true;
        },

        cerrarModal() {
          this.modalAbierto = false;
        },

        // Genera Pokémon aleatoriamente para cada equipo
        generarPokemonAleatorios() {
          this.pokemonsJugador1 = [];
          this.pokemonsJugador2 = [];
          let pokemonsDisponibles = [...this.todosLosPokemon];
          for (let i = 0; i < 5; i++) {
            let indiceAleatorio1 = Math.floor(Math.random() * pokemonsDisponibles.length);
            let p1 = Object.assign({}, pokemonsDisponibles[indiceAleatorio1]);
            p1.derrota = false;
            this.pokemonsJugador1.push(p1);
            pokemonsDisponibles.splice(indiceAleatorio1, 1);
            let indiceAleatorio2 = Math.floor(Math.random() * pokemonsDisponibles.length);
            let p2 = Object.assign({}, pokemonsDisponibles[indiceAleatorio2]);
            p2.derrota = false;
            this.pokemonsJugador2.push(p2);
            pokemonsDisponibles.splice(indiceAleatorio2, 1);
          }
        },

        // Vacía el tablero y reinicia las variables de la pelea
        vaciarTablero() {
          this.pokemonsJugador1 = Array.from({ length: 5 }, () => ({}));
          this.pokemonsJugador2 = Array.from({ length: 5 }, () => ({}));
          this.activePokemonJugador1 = null;
          this.activePokemonJugador2 = null;
          this.battleLog = [];
          this.battleModalAbierto = false;
          this.currentBattleIndex = 0;
        },

        /* -----------------------------------------------------------------
         * La siguiente lógica permite que cada batalla se realice entre
         * el Pokémon de la misma posición (primer vs. primer, segundo vs. segundo, etc.).
         * Al terminar una pelea se cierra el modal, se marca al perdedor (mostrando la imagen ./img/dorso.png)
         * y, al volver a presionar "Comenzar Batalla", se usa el siguiente par hasta definir un ganador.
         * ----------------------------------------------------------------- */
        
        // Inicia la batalla con el par de Pokémon en la posición currentBattleIndex
        comenzarBatalla() {
          // Si ya se han realizado todas las peleas o si alguno de los equipos ya no tiene Pokémon
          if (
            this.currentBattleIndex >= this.pokemonsJugador1.length ||
            this.remainingJugador1 === 0 ||
            this.remainingJugador2 === 0
          ) {
            this.mostrarGanador();
            return;
          }
          // Si no hay Pokémon asignados, se generan aleatoriamente
          if (!this.pokemonsJugador1.some(p => p.nombre) || !this.pokemonsJugador2.some(p => p.nombre)) {
            this.generarPokemonAleatorios();
          }
          this.iniciarBatallaConIndice(this.currentBattleIndex);
        },

        // Inicia la batalla para el par en el índice indicado
        iniciarBatallaConIndice(index) {
          const p1 = this.pokemonsJugador1[index];
          const p2 = this.pokemonsJugador2[index];
          // Copiamos los datos y asignamos la vida según la estadística 'hp'
          this.activePokemonJugador1 = Object.assign({}, p1);
          this.activePokemonJugador1.vida = this.obtenerEstadistica(p1, 'hp');
          this.activePokemonJugador2 = Object.assign({}, p2);
          this.activePokemonJugador2.vida = this.obtenerEstadistica(p2, 'hp');
          this.turno = 1;
          this.battleLog = [];
          this.batallaFinalizada = false;
          this.battleModalAbierto = true;
          this.simularPelea();
        },

        // Simula la pelea entre los Pokémon activos hasta que uno (o ambos) sea derrotado.
        // Al finalizar, se incrementa currentBattleIndex y se cierra el modal.
        async simularPelea() {
          while (this.activePokemonJugador1.vida > 0 && this.activePokemonJugador2.vida > 0) {
            await this.delay(1000);
            await this.atacarTurno();
          }
          // Se marca al o los Pokémon derrotados y se actualiza la carta (mostrando el dorso)
          if (this.activePokemonJugador1.vida <= 0 && this.activePokemonJugador2.vida <= 0) {
            this.battleLog.push(`¡Ambos Pokémon han sido derrotados!`);
            this.pokemonsJugador1[this.currentBattleIndex].derrota = true;
            this.pokemonsJugador2[this.currentBattleIndex].derrota = true;
          } else if (this.activePokemonJugador1.vida <= 0) {
            this.battleLog.push(`${this.activePokemonJugador1.nombre} ha sido derrotado!`);
            this.pokemonsJugador1[this.currentBattleIndex].derrota = true;
          } else if (this.activePokemonJugador2.vida <= 0) {
            this.battleLog.push(`${this.activePokemonJugador2.nombre} ha sido derrotado!`);
            this.pokemonsJugador2[this.currentBattleIndex].derrota = true;
          }
          this.batallaFinalizada = true;
          // Se espera 2 segundos para que se puedan ver los resultados, se incrementa el índice y se cierra el modal.
          await this.delay(2000);
          this.currentBattleIndex++;
          this.cerrarBatallaModal();
        },

        // Ejecuta un turno de ataque: se elige aleatoriamente uno de dos movimientos válidos
        async atacarTurno() {
          let atacante, defensor;
          if (this.turno === 1) {
            atacante = this.activePokemonJugador1;
            defensor = this.activePokemonJugador2;
          } else {
            atacante = this.activePokemonJugador2;
            defensor = this.activePokemonJugador1;
          }
          const movimientos = await this.seleccionarDosMovimientos(atacante);
          if (movimientos.length < 2) {
            this.battleLog.push("No se encontraron movimientos válidos para " + atacante.nombre);
            return;
          }
          const indiceAleatorio = Math.floor(Math.random() * 2);
          const movimientoElegido = movimientos[indiceAleatorio];
          let defensa = this.obtenerEstadistica(defensor, 'defense');
          let damage = movimientoElegido.power - defensa;
          if (damage < 0) damage = 0;
          defensor.vida -= damage;
          this.battleLog.push(`${atacante.nombre} usa ${movimientoElegido.nombreAtaque} causando ${damage} puntos de daño a ${defensor.nombre}.`);
          if (defensor.vida <= 0) {
            this.battleLog.push(`${defensor.nombre} ha sido derrotado!`);
          }
          // Alterna el turno
          this.turno = this.turno === 1 ? 2 : 1;
        },

        // Extrae el valor base de la estadística solicitada (por ejemplo, "hp" o "defense")
        obtenerEstadistica(pokemon, statName) {
          const statObj = pokemon.stats ? pokemon.stats.find(s => s.stat.name === statName) : null;
          return statObj ? statObj.base_stat : 0;
        },

        // Obtiene el detalle de un movimiento a partir de su URL
        async obtenerDetalleMovimiento(url) {
          const res = await fetch(url);
          return await res.json();
        },

        // Selecciona dos movimientos válidos (con power distinto de null) de forma aleatoria para el Pokémon
        async seleccionarDosMovimientos(pokemon) {
          let movimientosValidos = [];
          let movesShuffled = pokemon.movimientos.slice();
          for (let i = movesShuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [movesShuffled[i], movesShuffled[j]] = [movesShuffled[j], movesShuffled[i]];
          }
          for (let moveObj of movesShuffled) {
            try {
              let detalleMovimiento = await this.obtenerDetalleMovimiento(moveObj.move.url);
              if (detalleMovimiento.power !== null) {
                let nombreAtaque = (detalleMovimiento.names && detalleMovimiento.names[5])
                  ? detalleMovimiento.names[5].name
                  : detalleMovimiento.name;
                movimientosValidos.push({
                  nombreAtaque: nombreAtaque,
                  power: detalleMovimiento.power
                });
                if (movimientosValidos.length === 2) break;
              }
            } catch (error) {
              console.error("Error al obtener el detalle del movimiento", error);
            }
          }
          return movimientosValidos;
        },

        // Retardo para simular el paso del tiempo entre turnos
        delay(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        },

        // Cierra el modal de batalla y reinicia las variables activas
        cerrarBatallaModal() {
          this.battleModalAbierto = false;
          this.activePokemonJugador1 = null;
          this.activePokemonJugador2 = null;
        },

        // Muestra un mensaje indicando el ganador general del juego.
        mostrarGanador() {
          let ganador;
          if (this.remainingJugador1 > this.remainingJugador2) {
            ganador = "Jugador 1";
          } else if (this.remainingJugador2 > this.remainingJugador1) {
            ganador = "Jugador 2";
          } else {
            ganador = "Ninguno (Empate)";
          }
          alert("El juego ha terminado. Ganador: " + ganador);
        }
      }
    });

    app.mount("#app");
  </script>
</body>
</html>
